# -*- coding: utf-8 -*-
"""RandomForest+SMOTE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ehYrONLJ2D_M-p3bg9rME5kamBA66z4X
"""

# -*- coding: utf-8 -*-
"""Classificação de Diabetes com Random Forest e SMOTE"""

# !pip install imbalanced-learn

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, ConfusionMatrixDisplay, RocCurveDisplay

from imblearn.over_sampling import SMOTE
from imblearn.pipeline import Pipeline as ImbPipeline

# Caminho do arquivo CSV
file_path = '/content/drive/MyDrive/Datasets/diabetes.csv'

# Carregamento do dataset
try:
    df = pd.read_csv(file_path)
    print("Dados carregados com sucesso.")
except FileNotFoundError:
    print(f"ERRO: Arquivo não encontrado em: {file_path}")
    raise SystemExit("Verifique o caminho e monte o Google Drive corretamente.")

# Tratamento de valores inválidos
cols_to_fix = ['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI']
df[cols_to_fix] = df[cols_to_fix].replace(0, np.nan)

# Separação entre preditores e alvo
X = df.drop(columns='Outcome')
y = df['Outcome']

# Divisão estratificada em treino e teste
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)
print(f"\nDados separados: Treino ({len(X_train)}), Teste ({len(X_test)}).")

# Pipeline com pré-processamento, SMOTE e modelo
pipeline = ImbPipeline(steps=[
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler()),
    ('smote', SMOTE(sampling_strategy='minority', random_state=42)),
    ('classifier', RandomForestClassifier(random_state=42))
])

# Espaço de busca para RandomizedSearchCV
param_grid = {
    'classifier__n_estimators': [100, 300, 500],
    'classifier__max_depth': [10, 20, None],
    'classifier__min_samples_split': [2, 5],
    'classifier__min_samples_leaf': [1, 2],
    'classifier__max_features': ['sqrt', 'log2']
}

# Otimização com validação cruzada
print("\nIniciando busca de hiperparâmetros (com SMOTE)...")
random_search = RandomizedSearchCV(
    estimator=pipeline,
    param_distributions=param_grid,
    n_iter=15,
    cv=5,
    scoring='f1',
    random_state=42,
    n_jobs=-1
)
random_search.fit(X_train, y_train)

# Melhor pipeline encontrado
best_pipeline = random_search.best_estimator_
print("\nBusca concluída.")
print(f"Melhores parâmetros:\n{random_search.best_params_}")
print(f"Melhor F1-Score (CV): {random_search.best_score_:.4f}")

# Avaliação no conjunto de teste
y_pred = best_pipeline.predict(X_test)
print("="*50)
print("RELATÓRIO DE CLASSIFICAÇÃO - TESTE (COM SMOTE)")
print("="*50)
print(classification_report(y_test, y_pred, target_names=['Não Diabetes (0)', 'Diabetes (1)']))

# Visualizações

# Distribuição original da variável alvo
plt.figure(figsize=(6, 4))
df['Outcome'].value_counts().plot(kind='bar', color=['skyblue', 'salmon'])
plt.title('Distribuição Original de Diagnóstico de Diabetes')
plt.xlabel('Diagnóstico')
plt.ylabel('Número de Pacientes')
plt.xticks(rotation=0)
plt.grid(axis='y', alpha=0.7)
plt.show()

# Matriz de confusão normalizada
ConfusionMatrixDisplay.from_estimator(
    best_pipeline, X_test, y_test,
    cmap='Blues', normalize='true',
    display_labels=['Não Diabetes (0)', 'Diabetes (1)']
)
plt.title('Matriz de Confusão Normalizada (Com SMOTE)')
plt.show()

# Curva ROC e AUC
plt.figure(figsize=(8, 6))
roc_display = RocCurveDisplay.from_estimator(best_pipeline, X_test, y_test)
plt.plot([0, 1], [0, 1], 'r--', label='Classificador Aleatório')
plt.title(f'Curva ROC - AUC: {roc_display.roc_auc:.4f} (Com SMOTE)')
plt.xlabel('Taxa de Falso Positivo')
plt.ylabel('Taxa de Verdadeiro Positivo')
plt.legend(loc="lower right")
plt.grid(alpha=0.5)
plt.show()